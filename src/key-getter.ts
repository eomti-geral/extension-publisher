#!/usr/bin/env node
import { createServer, type IncomingMessage, type ServerResponse } from 'node:http';
import { URL } from 'node:url';
import * as p from '@clack/prompts';
import open from 'open';
import getPort from 'get-port';
import pDefer from 'p-defer';
import { config } from 'dotenv';
import { sendRefreshToken } from './api-sender';
import { writeFile, readFile } from 'fs/promises';
import { join } from 'path';

config();

if (typeof fetch !== 'function') {
    throw new TypeError('This script requires Node.js 18.0 or newer because it relies on the global `fetch` function.');
}

type Task = {
    title: string;
    task: (message: (message: string) => void) => Promise<string | undefined>;
    enabled?: boolean;
};

type GoogleTokenResponse = {
    refresh_token: string;
    error?: string;
};

async function main() {
    


const approvalCode = pDefer<string>();
const port = await getPort();
const localhost = '127.0.0.1';

// Verificar se o modo dev est√° ativado
const isDev = process.argv.includes('--dev');

// Fun√ß√µes para gerenciar o timestamp
async function readEnvFile(): Promise<{ refreshToken?: string; timestamp?: string }> {
    try {
        const envPath = join(process.cwd(), '.env');
        const content = await readFile(envPath, 'utf-8');
        const lines = content.split('\n');
        
        const result: { refreshToken?: string; timestamp?: string } = {};
        
        for (const line of lines) {
            if (line.startsWith('GOOGLE_CLOUD_API_REFRESH_TOKEN=')) {
                result.refreshToken = line.split('=')[1]?.trim();
            } else if (line.startsWith('LAST_TOKEN_REQUEST=')) {
                result.timestamp = line.split('=')[1]?.trim();
            }
        }
        
        return result;
    } catch (error) {
        return {};
    }
}

function hasOneDayPassed(timestamp: string): boolean {
    const lastRequest = new Date(timestamp);
    const now = new Date();
    const oneDayInMs = 24 * 60 * 60 * 1000;
    return (now.getTime() - lastRequest.getTime()) >= oneDayInMs;
}

async function writeToEnvFile(refreshToken: string): Promise<string> {
    const envPath = join(process.cwd(), '.env');
    const date = new Date().toISOString();

    // L√™ o conte√∫do atual do arquivo
    let content = await readFile(envPath, 'utf-8');
    
    // Remove todas as se√ß√µes antigas de token
    const sections = content.split('##############################################################################');
    content = sections[0]; // Mant√©m apenas a primeira parte (vari√°veis originais)

    // Prepara a nova se√ß√£o de token
    const newSection = [
        '##############################################################################',
        '# Bellow variabels were automatically generated by the script. Do not edit it manually.',
        '# Refresh token generated automatically',
        `GOOGLE_CLOUD_API_REFRESH_TOKEN=${refreshToken}`,
        '# Last token request timestamp',
        `LAST_TOKEN_REQUEST=${date}`,
    ].join('\n');

    // Combina o conte√∫do original com a nova se√ß√£o
    const updatedContent = content.trim() + '\n' + newSection + '\n';
    
    try {
        await writeFile(envPath, updatedContent, 'utf-8');
        return 'Successfully wrote refresh token to .env file';
    } catch (error) {
        throw new Error(`Failed to write to .env file: ${error instanceof Error ? error.message : String(error)}`);
    }
}

// TODO: Remove after https://github.com/natemoo-re/clack/issues/181
const tasks = async (tasks: Task[]): Promise<void> => {
    for (const task of tasks) {
        if (task.enabled === false) {
            continue;
        }

        const s = p.spinner();
        s.start(task.title);
        // eslint-disable-next-line no-await-in-loop -- Sequential
        const result = await task.task(s.message);
        s.stop(result ?? task.title);
    }
};

const server = createServer((request: IncomingMessage, response: ServerResponse) => {
    const searchParameters = new URL(request.url ?? '', `http://${localhost}`).searchParams;
    if (searchParameters.has('code')) {
        approvalCode.resolve(searchParameters.get('code') ?? '');
        response.writeHead(200, { 'Content-Type': 'text/html' });
        response.end('You can close this tab now. <script>window.close()</script>');
        server.close();
        return;
    }

    response.writeHead(400, { 'Content-Type': 'text/plain' });
    response.end('No `code` found in the URL. WHO R U?');
});

server.listen(port, localhost);

const serverUrl = `http://${localhost}:${port}`;

function required(input: string): string | undefined {
    if (input.trim() === '') {
        return 'Required';
    }
}

async function getRefreshToken(): Promise<string> {
    const request = await fetch('https://accounts.google.com/o/oauth2/token', {
        method: 'POST',
        body: new URLSearchParams([
            ['client_id', group.clientId.trim()],
            ['client_secret', group.clientSecret.trim()],
            ['code', code],
            ['grant_type', 'authorization_code'],
            ['redirect_uri', serverUrl], // Unused but required
        ]),
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
    });

    if (!request.ok) {
        throw new Error('Error while getting the refresh token: ' + request.statusText);
    }

    const response = await request.json() as GoogleTokenResponse;

    if (response.error) {
        throw new Error('Error while getting the refresh token: ' + response.error);
    }

    return response.refresh_token;
}

function getLoginUrl(clientId: string): string {
    const url = new URL('https://accounts.google.com/o/oauth2/auth');
    url.searchParams.set('response_type', 'code');
    url.searchParams.set('access_type', 'offline');
    url.searchParams.set('client_id', clientId.trim());
    url.searchParams.set('scope', 'https://www.googleapis.com/auth/chromewebstore');
    url.searchParams.set('redirect_uri', serverUrl);
    return url.href;
}

// Antes de iniciar o processo, verificar o timestamp
const envData = await readEnvFile();

p.intro('‚öôÔ∏è  Iniciando utilit√°rio key-getter...');
p.log.info('üîë  Este utilit√°rio ir√° gerar um refresh token para a API do Google Cloud. Ele ser√° salvo no arquivo .env.');
if (isDev) {
    p.log.info('Executando em modo de desenvolvimento...');
    p.log.info('üîë O refresh token ser√° salvo no arquivo .env. Voc√™ pode usar o comando `npm run dev` para gerar o bundle de desenvolvimento.');
}

if (isDev && envData.refreshToken && envData.timestamp && !hasOneDayPassed(envData.timestamp)) {
    p.log.info('Checking last token request...');
    const lastRequestDate = new Date(envData.timestamp);
    p.outro(`‚ùå O √∫ltimo refresh token foi gerado em ${lastRequestDate.toLocaleString()} (menos de 24 horas).`);
    process.exit(0);
}

const { env } = process;
const clientId = env.GOOGLE_CLOUD_API_CLIENT_ID;
const clientSecret = env.GOOGLE_CLOUD_API_CLIENT_SECRET;
const gitLabToken = env.GIT_LAB_ACCESS_TOKEN;

if (!clientId || !clientSecret) {
    console.error('Error: GOOGLE_CLOUD_API_CLIENT_ID and GOOGLE_CLOUD_API_CLIENT_SECRET environment variables are required');
    console.error('Please set them in your .env file');
    process.exit(1);
}

if (!gitLabToken) {
    console.error('Error: GIT_LAB_ACCESS_TOKEN environment variable is required');
    console.error('Please set it in your .env file');
    process.exit(1);
}

const group = {
    clientId,
    clientSecret,
    open: true,
};

let code: string;
let refreshToken: string;

await tasks([
    {
        title: 'Opening the login page in the browser',
        async task() {
            const instructions = 'Complete the process in the browser. Follow its steps and warnings (this is your own personal app)';
            if (group.open) {
                await open(getLoginUrl(group.clientId));
                return instructions;
            }

            return instructions + '\n\n   ' + getLoginUrl(group.clientId);
        },
    },
    {
        title: 'Waiting for you in the browser',
        async task() {
            code = await approvalCode.promise;
            return 'Approval code received from Google';
        },
    },
    {
        title: 'Asking Google for the refresh token',
        async task() {
            refreshToken = await getRefreshToken();
            // Adicionar o refresh token √†s vari√°veis de ambiente para ser enviado junto
            env.GOOGLE_CLOUD_API_REFRESH_TOKEN = refreshToken;
            return 'Refresh token obtained successfully';
        },
    },
    {
        title: 'Writing refresh token to .env file',
        enabled: isDev,
        async task() {
            return writeToEnvFile(refreshToken);
        },
    },
    {
        title: 'Enviando GOOGLE_CLOUD_API_CLIENT_ID para o GitLab',
        enabled: !isDev,
        async task() {
            return sendRefreshToken(gitLabToken, env.GOOGLE_CLOUD_API_CLIENT_ID!, 'GOOGLE_CLOUD_API_CLIENT_ID');
        },
    },
    {
        title: 'Enviando GOOGLE_CLOUD_API_CLIENT_SECRET para o GitLab',
        enabled: !isDev,
        async task() {
            return sendRefreshToken(gitLabToken, env.GOOGLE_CLOUD_API_CLIENT_SECRET!, 'GOOGLE_CLOUD_API_CLIENT_SECRET');
        },
    },
    {
        title: 'Enviando GOOGLE_CLOUD_API_REFRESH_TOKEN para o GitLab',
        enabled: !isDev,
        async task() {
            return sendRefreshToken(gitLabToken, env.GOOGLE_CLOUD_API_REFRESH_TOKEN!, 'GOOGLE_CLOUD_API_REFRESH_TOKEN');
        },
    },
    {
        title: 'Finalizando procedimento',
        async task() {
            return isDev 
                ? '‚ú® Processo conclu√≠do com sucesso! O refresh token foi salvo no arquivo .env.'
                : '‚ú® Processo conclu√≠do com sucesso! Todas as vari√°veis Google foram enviadas para o GitLab.';
        },
    },
]);

// Finaliza o processo ap√≥s completar todas as tarefas
}

main()