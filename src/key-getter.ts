#!/usr/bin/env node
import { createServer, type IncomingMessage, type ServerResponse } from 'node:http';
import { URL } from 'node:url';
import * as p from '@clack/prompts';
import open from 'open';
import getPort from 'get-port';
import pDefer from 'p-defer';
import { config } from 'dotenv';
import { sendRefreshToken } from './api-sender.js';
import { writeFile, readFile } from 'fs/promises';
import { join } from 'path';

config();

if (typeof fetch !== 'function') {
    throw new TypeError('This script requires Node.js 18.0 or newer because it relies on the global `fetch` function.');
}

type Task = {
    title: string;
    task: (message: (message: string) => void) => Promise<string | undefined>;
    enabled?: boolean;
};

type GoogleTokenResponse = {
    refresh_token: string;
    error?: string;
};

const approvalCode = pDefer<string>();
const port = await getPort();
const localhost = '127.0.0.1';

// Verificar se o modo dev está ativado
const isDev = process.argv.includes('--dev');

// Funções para gerenciar o timestamp
async function readEnvFile(): Promise<{ refreshToken?: string; timestamp?: string }> {
    try {
        const envPath = join(process.cwd(), '.env');
        const content = await readFile(envPath, 'utf-8');
        const lines = content.split('\n');
        
        const result: { refreshToken?: string; timestamp?: string } = {};
        
        for (const line of lines) {
            if (line.startsWith('GOOGLE_CLOUD_API_REFRESH_TOKEN=')) {
                result.refreshToken = line.split('=')[1]?.trim();
            } else if (line.startsWith('LAST_TOKEN_REQUEST=')) {
                result.timestamp = line.split('=')[1]?.trim();
            }
        }
        
        return result;
    } catch (error) {
        return {};
    }
}

function hasOneDayPassed(timestamp: string): boolean {
    const lastRequest = new Date(timestamp);
    const now = new Date();
    const oneDayInMs = 24 * 60 * 60 * 1000;
    return (now.getTime() - lastRequest.getTime()) >= oneDayInMs;
}

async function writeToEnvFile(refreshToken: string): Promise<string> {
    const envPath = join(process.cwd(), '.env');
    const date = new Date().toISOString();
    const content = 
    [
        '##############################################################################',
        '# Bellow variabels were automatically generated by the script. Do not edit it manually.',
        '# Refresh token generated automatically',
        `GOOGLE_CLOUD_API_REFRESH_TOKEN=${refreshToken}`,
        `# Last token request timestamp`,
        `LAST_TOKEN_REQUEST=${date}`,
    ].join('\n') 
    
    try {
        await writeFile(envPath, content, { flag: 'a' });
        return 'Successfully wrote refresh token to .env file';
    } catch (error) {
        throw new Error(`Failed to write to .env file: ${error instanceof Error ? error.message : String(error)}`);
    }
}

// TODO: Remove after https://github.com/natemoo-re/clack/issues/181
const tasks = async (tasks: Task[]): Promise<void> => {
    for (const task of tasks) {
        if (task.enabled === false) {
            continue;
        }

        const s = p.spinner();
        s.start(task.title);
        // eslint-disable-next-line no-await-in-loop -- Sequential
        const result = await task.task(s.message);
        s.stop(result ?? task.title);
    }
};

const server = createServer((request: IncomingMessage, response: ServerResponse) => {
    const searchParameters = new URL(request.url ?? '', `http://${localhost}`).searchParams;
    if (searchParameters.has('code')) {
        approvalCode.resolve(searchParameters.get('code') ?? '');
        response.writeHead(200, { 'Content-Type': 'text/html' });
        response.end('You can close this tab now. <script>window.close()</script>');
        server.close();
        return;
    }

    response.writeHead(400, { 'Content-Type': 'text/plain' });
    response.end('No `code` found in the URL. WHO R U?');
});

server.listen(port, localhost);

const serverUrl = `http://${localhost}:${port}`;

function required(input: string): string | undefined {
    if (input.trim() === '') {
        return 'Required';
    }
}

async function getRefreshToken(): Promise<string> {
    const request = await fetch('https://accounts.google.com/o/oauth2/token', {
        method: 'POST',
        body: new URLSearchParams([
            ['client_id', group.clientId.trim()],
            ['client_secret', group.clientSecret.trim()],
            ['code', code],
            ['grant_type', 'authorization_code'],
            ['redirect_uri', serverUrl], // Unused but required
        ]),
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
    });

    if (!request.ok) {
        throw new Error('Error while getting the refresh token: ' + request.statusText);
    }

    const response = await request.json() as GoogleTokenResponse;

    if (response.error) {
        throw new Error('Error while getting the refresh token: ' + response.error);
    }

    return response.refresh_token;
}

function getLoginUrl(clientId: string): string {
    const url = new URL('https://accounts.google.com/o/oauth2/auth');
    url.searchParams.set('response_type', 'code');
    url.searchParams.set('access_type', 'offline');
    url.searchParams.set('client_id', clientId.trim());
    url.searchParams.set('scope', 'https://www.googleapis.com/auth/chromewebstore');
    url.searchParams.set('redirect_uri', serverUrl);
    return url.href;
}

// Antes de iniciar o processo, verificar o timestamp
const envData = await readEnvFile();

if (envData.refreshToken && envData.timestamp && !hasOneDayPassed(envData.timestamp)) {
    p.intro('Checking last token request...');
    const lastRequestDate = new Date(envData.timestamp);
    console.log(`❌ O último refresh token foi gerado em ${lastRequestDate.toLocaleString()} (menos de 24 horas).`);
    console.log('Por favor, aguarde 24 horas antes de gerar um novo token.');
    process.exit(0);
}

p.intro('Follow the steps at this URL to generate the API keys, then enter them below to generate the refresh token.\n   https://github.com/fregante/chrome-webstore-upload-keys');

const { env } = process;
const clientId = env.GOOGLE_CLOUD_API_CLIENT_ID;
const clientSecret = env.GOOGLE_CLOUD_API_CLIENT_SECRET;
const gitLabToken = env.GIT_LAB_ACCESS_TOKEN;

if (!clientId || !clientSecret) {
    console.error('Error: GOOGLE_CLOUD_API_CLIENT_ID and GOOGLE_CLOUD_API_CLIENT_SECRET environment variables are required');
    console.error('Please set them in your .env file');
    process.exit(1);
}

if (!gitLabToken) {
    console.error('Error: GIT_LAB_ACCESS_TOKEN environment variable is required');
    console.error('Please set it in your .env file');
    process.exit(1);
}

const group = {
    clientId,
    clientSecret,
    open: true,
};

let code: string;
let refreshToken: string;

await tasks([
    {
        title: 'Opening the login page in the browser',
        async task() {
            const instructions = 'Complete the process in the browser. Follow its steps and warnings (this is your own personal app)';
            if (group.open) {
                await open(getLoginUrl(group.clientId));
                return instructions;
            }

            return instructions + '\n\n   ' + getLoginUrl(group.clientId);
        },
    },
    {
        title: 'Waiting for you in the browser',
        async task() {
            code = await approvalCode.promise;
            return 'Approval code received from Google';
        },
    },
    {
        title: 'Asking Google for the refresh token',
        async task() {
            refreshToken = await getRefreshToken();
            // Adicionar o refresh token às variáveis de ambiente para ser enviado junto
            env.GOOGLE_CLOUD_API_REFRESH_TOKEN = refreshToken;
            return 'Refresh token obtained successfully';
        },
    },
    {
        title: 'Writing refresh token to .env file',
        enabled: isDev,
        async task() {
            return writeToEnvFile(refreshToken);
        },
    },
    {
        title: 'Enviando GOOGLE_CLOUD_API_CLIENT_ID para o GitLab',
        enabled: !isDev,
        async task() {
            return sendRefreshToken(gitLabToken, env.GOOGLE_CLOUD_API_CLIENT_ID!, 'GOOGLE_CLOUD_API_CLIENT_ID');
        },
    },
    {
        title: 'Enviando GOOGLE_CLOUD_API_CLIENT_SECRET para o GitLab',
        enabled: !isDev,
        async task() {
            return sendRefreshToken(gitLabToken, env.GOOGLE_CLOUD_API_CLIENT_SECRET!, 'GOOGLE_CLOUD_API_CLIENT_SECRET');
        },
    },
    {
        title: 'Enviando GOOGLE_CLOUD_API_REFRESH_TOKEN para o GitLab',
        enabled: !isDev,
        async task() {
            return sendRefreshToken(gitLabToken, env.GOOGLE_CLOUD_API_REFRESH_TOKEN!, 'GOOGLE_CLOUD_API_REFRESH_TOKEN');
        },
    },
    {
        title: 'Finalizando procedimento',
        async task() {
            return isDev 
                ? '✨ Processo concluído com sucesso! O refresh token foi salvo no arquivo .env.'
                : '✨ Processo concluído com sucesso! Todas as variáveis Google foram enviadas para o GitLab.';
        },
    },
]);

// Finaliza o processo após completar todas as tarefas
process.exit(0);